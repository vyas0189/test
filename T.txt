package com.jpmorgan.proactive.tfe

import org.openrewrite.*
import org.openrewrite.yaml.*
import org.openrewrite.yaml.tree.Yaml
import org.openrewrite.internal.lang.Nullable
import java.util.regex.Pattern

class AwsDeploymentConfigRecipe : Recipe() {
    
    override fun getDisplayName(): String = "Update YAML zone_id with template handling"
    
    override fun getDescription(): String = 
        "Wraps YAML template expressions {{}} in quotes and updates zone_id to 'auto'"
    
    override fun getRecipeList(): List<Recipe> = listOf(
        PreprocessYamlTemplates(),
        ChangePropertyValue("zone_id", "auto", null, null, null)
    )
}

class PreprocessYamlTemplates : Recipe() {
    
    override fun getDisplayName(): String = "Preprocess YAML templates"
    
    override fun getDescription(): String = 
        "Wraps template expressions {{}} in quotes to make YAML parseable"
    
    override fun getVisitor(): TreeVisitor<*, ExecutionContext> = 
        YamlTemplateVisitor()
}

class YamlTemplateVisitor : YamlIsoVisitor<ExecutionContext>() {
    
    private val templatePattern = Pattern.compile("^(\\s*[^:]+):\\s*([^\"']*\\{\\{[^}]*\\}\\}[^\"']*)\\s*$")
    
    override fun visitDocuments(documents: Yaml.Documents, ctx: ExecutionContext): Yaml.Documents {
        val originalContent = documents.printAll()
        val processedContent = preprocessTemplates(originalContent)
        
        if (originalContent == processedContent) {
            return documents
        }
        
        // Reparse the YAML with wrapped templates
        val parser = YamlParser()
        val parsed = parser.parseInputs(
            listOf(Parser.Input.fromString(documents.sourcePath, processedContent)),
            null,
            ctx
        )
        
        if (parsed.size > 0) {
            val newDocument = parsed.iterator().next() as Yaml.Documents
            return newDocument.withSourcePath(documents.sourcePath)
        }
        
        return documents
    }
    
    private fun preprocessTemplates(content: String): String {
        return content.lines().joinToString("\n") { line ->
            if (shouldWrapLine(line)) {
                wrapTemplateInLine(line)
            } else {
                line
            }
        }
    }
    
    private fun shouldWrapLine(line: String): Boolean {
        val matcher = templatePattern.matcher(line)
        return matcher.matches() && !isAlreadyQuoted(matcher.group(2).trim())
    }
    
    private fun wrapTemplateInLine(line: String): String {
        val matcher = templatePattern.matcher(line)
        if (matcher.matches()) {
            val key = matcher.group(1)
            val value = matcher.group(2).trim()
            return "$key: \"$value\""
        }
        return line
    }
    
    private fun isAlreadyQuoted(value: String): Boolean {
        val trimmed = value.trim()
        return (trimmed.startsWith("\"") && trimmed.endsWith("\"")) ||
               (trimmed.startsWith("'") && trimmed.endsWith("'"))
    }
}

// Alternative implementation using ScanningRecipe for more control
class UpdateYamlZoneIdWithTemplates : ScanningRecipe<UpdateYamlZoneIdWithTemplates.Accumulator>() {
    
    data class Accumulator(val needsUpdate: Boolean = false)
    
    override fun getDisplayName(): String = "Update YAML zone_id handling templates"
    
    override fun getDescription(): String = 
        "Preprocesses YAML templates and updates zone_id to 'auto'"
    
    override fun getInitialValue(ctx: ExecutionContext): Accumulator = Accumulator()
    
    override fun getScanner(acc: Accumulator): TreeVisitor<*, ExecutionContext> = 
        object : TreeVisitor<Tree, ExecutionContext>() {
            
            override fun visit(tree: Tree?, ctx: ExecutionContext): Tree? {
                if (tree is SourceFile && isYamlFile(tree)) {
                    return processYamlFile(tree, ctx)
                }
                return tree
            }
            
            private fun isYamlFile(sourceFile: SourceFile): Boolean {
                val path = sourceFile.sourcePath.toString()
                return path.endsWith(".yml") || path.endsWith(".yaml")
            }
            
            private fun processYamlFile(sourceFile: SourceFile, ctx: ExecutionContext): SourceFile {
                val originalContent = sourceFile.printAll()
                val processedContent = preprocessTemplates(originalContent)
                
                // Parse the preprocessed content
                val yamlParser = YamlParser()
                val parseResults = yamlParser.parseInputs(
                    listOf(Parser.Input.fromString(sourceFile.sourcePath, processedContent)),
                    null,
                    ctx
                )
                
                if (parseResults.size == 0) {
                    return sourceFile
                }
                
                val parsedYaml = parseResults.iterator().next()
                
                // Apply the zone_id update
                val changePropertyVisitor = ChangePropertyValue("zone_id", "auto", null, null, null).getVisitor()
                val updatedYaml = changePropertyVisitor.visit(parsedYaml, ctx)
                
                return if (updatedYaml != null && updatedYaml is SourceFile) {
                    updatedYaml.withSourcePath(sourceFile.sourcePath)
                } else {
                    sourceFile
                }
            }
            
            private fun preprocessTemplates(content: String): String {
                val templatePattern = Pattern.compile("^(\\s*[^:]+):\\s*([^\"']*\\{\\{[^}]*\\}\\}[^\"']*)\\s*$", 
                                                    Pattern.MULTILINE)
                
                return templatePattern.matcher(content).replaceAll { matchResult ->
                    val key = matchResult.group(1)
                    val value = matchResult.group(2).trim()
                    if (!isAlreadyQuoted(value)) {
                        "$key: \"$value\""
                    } else {
                        matchResult.group(0)
                    }
                }
            }
            
            private fun isAlreadyQuoted(value: String): Boolean {
                val trimmed = value.trim()
                return (trimmed.startsWith("\"") && trimmed.endsWith("\"")) ||
                       (trimmed.startsWith("'") && trimmed.endsWith("'"))
            }
        }
}
