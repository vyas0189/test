Server-Side (FastAPI with ADK)
pythonfrom fastapi import FastAPI
from fastapi.responses import StreamingResponse
from google.adk.runners import Runner
from google.adk.agents import Agent
import json

app = FastAPI()

async def stream_agent_response(user_message: str):
    # Your agent setup
    agent = Agent(...)
    runner = Runner(agent=agent, ...)
    
    async for event in runner.run_async(user_id="user", session_id="session", new_message=user_message):
        # ADK events have different types
        if hasattr(event, 'content') and event.content:
            for part in event.content.parts:
                if hasattr(part, 'text') and part.text:
                    yield f"data: {json.dumps({'type': 'text', 'content': part.text})}\n\n"
        
        # Handle tool calls (MCP)
        if hasattr(event, 'tool_calls'):
            yield f"data: {json.dumps({'type': 'tool_call', 'data': str(event.tool_calls)})}\n\n"
    
    yield "data: [DONE]\n\n"

@app.post("/chat")
async def chat(request: ChatRequest):
    return StreamingResponse(
        stream_agent_response(request.message),
        media_type="text/event-stream"
    )
Client-Side Parsing
Python Client
pythonimport httpx
import json

async def parse_stream():
    async with httpx.AsyncClient() as client:
        async with client.stream("POST", "http://localhost:8000/chat", 
                                  json={"message": "Hello"}) as response:
            async for line in response.aiter_lines():
                if line.startswith("data: "):
                    data = line[6:]  # Remove "data: " prefix
                    
                    if data == "[DONE]":
                        break
                    
                    try:
                        parsed = json.loads(data)
                        if parsed["type"] == "text":
                            print(parsed["content"], end="", flush=True)
                        elif parsed["type"] == "tool_call":
                            print(f"\n[Tool Call]: {parsed['data']}")
                    except json.JSONDecodeError:
                        continue
JavaScript/TypeScript Client
javascriptasync function parseStream() {
  const response = await fetch('/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message: 'Hello' })
  });

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n\n');
    buffer = lines.pop(); // Keep incomplete chunk

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = line.slice(6);
        
        if (data === '[DONE]') return;
        
        try {
          const parsed = JSON.parse(data);
          if (parsed.type === 'text') {
            console.log(parsed.content);
          } else if (parsed.type === 'tool_call') {
            console.log('[Tool Call]:', parsed.data);
          }
        } catch (e) {
          // Skip malformed JSON
        }
      }
    }
  }
}
Key ADK Event Types to Handle
pythonfrom google.genai import types

async def stream_with_event_types(runner, user_message):
    async for event in runner.run_async(...):
        # Check event author (user, agent, or tool)
        author = getattr(event, 'author', None)
        
        # Text content
        if event.content and event.content.parts:
            for part in event.content.parts:
                if part.text:
                    yield {"type": "text", "author": author, "content": part.text}
                elif part.function_call:
                    yield {"type": "function_call", "name": part.function_call.name}
                elif part.function_response:
                    yield {"type": "function_response", "data": part.function_response}
Tips

Buffer incomplete chunks - SSE data can arrive in fragments
Handle different event types - ADK emits text, tool calls, and tool responses
Check the author field - Distinguishes between user, agent, and tool events
Use [DONE] signal - Indicates stream completion

Would you like me to elaborate on any specific part, such as handling specific MCP tool responses or error handling?
