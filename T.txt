package com.jpmorgan.proactive.tfe

import org.openrewrite.*
import org.openrewrite.yaml.*
import org.openrewrite.yaml.tree.Yaml
import java.util.regex.Pattern

class AwsDeploymentConfigRecipe : Recipe() {
    
    override fun getDisplayName(): String = "Update YAML zone_id with template handling"
    
    override fun getDescription(): String = 
        "Wraps YAML template expressions {{}} in quotes and updates zone_id to 'auto'."
    
    override fun getVisitor(): TreeVisitor<*, ExecutionContext> = 
        object : TreeVisitor<Tree, ExecutionContext>() {
            
            override fun visit(tree: Tree?, ctx: ExecutionContext): Tree? {
                if (tree is SourceFile && isYamlFile(tree)) {
                    return processYamlFile(tree, ctx)
                }
                return super.visit(tree, ctx)
            }
            
            private fun isYamlFile(sourceFile: SourceFile): Boolean {
                val path = sourceFile.sourcePath.toString()
                return path.endsWith(".yml") || path.endsWith(".yaml")
            }
            
            private fun processYamlFile(sourceFile: SourceFile, ctx: ExecutionContext): SourceFile {
                val originalContent = sourceFile.printAll()
                var modifiedContent = wrapTemplates(originalContent)
                modifiedContent = updateZoneIdValue(modifiedContent)
                
                if (originalContent != modifiedContent) {
                    try {
                        val parser = YamlParser()
                        val parsed = parser.parse(ctx, modifiedContent)
                        val parsedList = parsed.toList()
                        if (parsedList.isNotEmpty() && parsedList[0] is Yaml.Documents) {
                            return (parsedList[0] as Yaml.Documents).withSourcePath(sourceFile.sourcePath)
                        }
                    } catch (e: Exception) {
                        // Fall back to original if parsing fails
                    }
                }
                
                return sourceFile
            }
            
            private fun wrapTemplates(content: String): String {
                val templatePattern = Pattern.compile("^(\\s*[^:]+):\\s*([^\"']*\\{\\{[^}]*\\}\\}[^\"']*)\\s*$", 
                                                    Pattern.MULTILINE)
                
                return templatePattern.matcher(content).replaceAll { matchResult ->
                    val key = matchResult.group(1)
                    val value = matchResult.group(2).trim()
                    
                    if (!isQuoted(value)) {
                        "$key: \"$value\""
                    } else {
                        matchResult.group(0)
                    }
                }
            }
            
            private fun updateZoneIdValue(content: String): String {
                val zoneIdPattern = Pattern.compile("^(\\s*zone_id\\s*):\\s*(.*)$", Pattern.MULTILINE)
                return zoneIdPattern.matcher(content).replaceAll("$1: auto")
            }
            
            private fun isQuoted(value: String): Boolean {
                val trimmed = value.trim()
                return (trimmed.startsWith("\"") && trimmed.endsWith("\"")) ||
                       (trimmed.startsWith("'") && trimmed.endsWith("'"))
            }
        }

// Alternative simpler approach using string manipulation only
class SimpleYamlTemplateRecipe : Recipe() {
    
    override fun getDisplayName(): String = "Simple YAML template and zone_id update"
    
    override fun getDescription(): String = 
        "Wraps YAML templates in quotes and updates zone_id using string manipulation."
    
    override fun getVisitor(): TreeVisitor<*, ExecutionContext> = 
        object : TreeVisitor<Tree, ExecutionContext>() {
            
            override fun visit(tree: Tree?, ctx: ExecutionContext): Tree? {
                if (tree is Yaml.Documents) {
                    return processYamlDocument(tree, ctx)
                }
                return super.visit(tree, ctx)
            }
            
            private fun processYamlDocument(documents: Yaml.Documents, ctx: ExecutionContext): Yaml.Documents {
                val originalContent = documents.printAll()
                var modifiedContent = wrapTemplates(originalContent)
                modifiedContent = updateZoneIdValue(modifiedContent)
                
                if (originalContent != modifiedContent) {
                    try {
                        val parser = YamlParser()
                        val parsed = parser.parse(ctx, modifiedContent)
                        val parsedList = parsed.toList()
                        if (parsedList.isNotEmpty() && parsedList[0] is Yaml.Documents) {
                            return (parsedList[0] as Yaml.Documents).withSourcePath(documents.sourcePath)
                        }
                    } catch (e: Exception) {
                        // Fall back to original if parsing fails
                    }
                }
                
                return documents
            }
            
            private fun wrapTemplates(content: String): String {
                val templatePattern = Pattern.compile("^(\\s*[^:]+):\\s*([^\"']*\\{\\{[^}]*\\}\\}[^\"']*)\\s*$", 
                                                    Pattern.MULTILINE)
                
                return templatePattern.matcher(content).replaceAll { matchResult ->
                    val key = matchResult.group(1)
                    val value = matchResult.group(2).trim()
                    
                    if (!isQuoted(value)) {
                        "$key: \"$value\""
                    } else {
                        matchResult.group(0)
                    }
                }
            }
            
            private fun updateZoneIdValue(content: String): String {
                val zoneIdPattern = Pattern.compile("^(\\s*zone_id\\s*):\\s*(.*)$", Pattern.MULTILINE)
                return zoneIdPattern.matcher(content).replaceAll("$1: auto")
            }
            
            private fun isQuoted(value: String): Boolean {
                val trimmed = value.trim()
                return (trimmed.startsWith("\"") && trimmed.endsWith("\"")) ||
                       (trimmed.startsWith("'") && trimmed.endsWith("'"))
            }
        }
}
