package com.example.recipes

import org.openrewrite.*
import org.openrewrite.yaml.*
import org.openrewrite.yaml.tree.Yaml
import org.openrewrite.internal.lang.Nullable
import java.util.regex.Pattern

class UpdateYamlWithTemplateHandling : Recipe() {
    
    override fun getDisplayName(): String = "Update YAML zone_id with template handling"
    
    override fun getDescription(): String = 
        "Wraps YAML template expressions {{}} in quotes and updates zone_id to 'auto'"
    
    override fun getRecipeList(): List<Recipe> = listOf(
        PreprocessYamlTemplates(),
        ChangePropertyValue("zone_id", "auto", null, null, null)
    )
}

class PreprocessYamlTemplates : Recipe() {
    
    override fun getDisplayName(): String = "Preprocess YAML templates"
    
    override fun getDescription(): String = 
        "Wraps template expressions {{}} in quotes to make YAML parseable"
    
    override fun getVisitor(): TreeVisitor<*, ExecutionContext> = 
        object : YamlSourceVisitor<ExecutionContext>() {
            
            private val templatePattern = Pattern.compile("(\\{\\{[^}]*\\}\\})")
            
            override fun visitSource(source: SourceFile, ctx: ExecutionContext): SourceFile {
                if (source !is Yaml.Documents) {
                    return source
                }
                
                val originalContent = source.printAll()
                val processedContent = wrapTemplatesInQuotes(originalContent)
                
                if (originalContent == processedContent) {
                    return source
                }
                
                // Reparse the YAML with wrapped templates
                return YamlParser().parse(processedContent)
                    .map { it.withSourcePath(source.sourcePath) }
                    .first() as SourceFile
            }
            
            private fun wrapTemplatesInQuotes(content: String): String {
                val lines = content.split("\n")
                val processedLines = lines.map { line ->
                    if (containsUnquotedTemplate(line)) {
                        wrapTemplateInLine(line)
                    } else {
                        line
                    }
                }
                return processedLines.joinToString("\n")
            }
            
            private fun containsUnquotedTemplate(line: String): Boolean {
                val matcher = templatePattern.matcher(line)
                while (matcher.find()) {
                    val template = matcher.group(1)
                    val beforeTemplate = line.substring(0, matcher.start())
                    val afterTemplate = line.substring(matcher.end())
                    
                    // Check if template is already quoted
                    val beforeTrimmed = beforeTemplate.trimEnd()
                    val afterTrimmed = afterTemplate.trimStart()
                    
                    val isAlreadyQuoted = (beforeTrimmed.endsWith("\"") && afterTrimmed.startsWith("\"")) ||
                                        (beforeTrimmed.endsWith("'") && afterTrimmed.startsWith("'"))
                    
                    if (!isAlreadyQuoted) {
                        return true
                    }
                }
                return false
            }
            
            private fun wrapTemplateInLine(line: String): String {
                val colonIndex = line.indexOf(':')
                if (colonIndex == -1) return line
                
                val key = line.substring(0, colonIndex)
                val value = line.substring(colonIndex + 1).trim()
                
                // Only wrap if the value contains templates and isn't already quoted
                if (templatePattern.matcher(value).find() && !isAlreadyQuoted(value)) {
                    return "$key: \"$value\""
                }
                
                return line
            }
            
            private fun isAlreadyQuoted(value: String): Boolean {
                val trimmed = value.trim()
                return (trimmed.startsWith("\"") && trimmed.endsWith("\"")) ||
                       (trimmed.startsWith("'") && trimmed.endsWith("'"))
            }
        }
}

// Alternative implementation using direct string manipulation before parsing
class UpdateYamlZoneIdWithTemplates : ScanningRecipe<String>() {
    
    override fun getDisplayName(): String = "Update YAML zone_id handling templates"
    
    override fun getDescription(): String = 
        "Preprocesses YAML templates and updates zone_id to 'auto'"
    
    override fun getInitialValue(ctx: ExecutionContext): String = ""
    
    override fun getScanner(acc: String): TreeVisitor<*, ExecutionContext> = 
        object : TreeVisitor<Tree, ExecutionContext>() {
            
            override fun visit(@Nullable tree: Tree?, ctx: ExecutionContext): Tree? {
                if (tree is SourceFile && tree.sourcePath.toString().endsWith(".yml") || 
                    tree is SourceFile && tree.sourcePath.toString().endsWith(".yaml")) {
                    
                    val originalContent = tree.printAll()
                    val processedContent = preprocessTemplates(originalContent)
                    
                    // Parse the preprocessed content
                    val yamlParser = YamlParser()
                    val parsedYaml = yamlParser.parse(processedContent).first()
                    
                    // Apply the zone_id update
                    val updatedYaml = ChangePropertyValue("zone_id", "auto", null, null, null)
                        .getVisitor()
                        .visit(parsedYaml, ctx)
                    
                    return updatedYaml?.withSourcePath(tree.sourcePath)
                }
                return tree
            }
            
            private fun preprocessTemplates(content: String): String {
                val templatePattern = Pattern.compile("^(\\s*[^:]+):\\s*([^\"']*\\{\\{[^}]*\\}\\}[^\"']*)\\s*$", 
                                                    Pattern.MULTILINE)
                
                return templatePattern.matcher(content).replaceAll { matchResult ->
                    val key = matchResult.group(1)
                    val value = matchResult.group(2).trim()
                    "$key: \"$value\""
                }
            }
        }
}
